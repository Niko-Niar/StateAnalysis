# Библиотека взаимодействия с ПАК Opti-Repair

## Цели и задачи библиотеки

- Чтение и анализ конфигурационных файлов
- Сохранение оперативных данных и событий
- Взаимодействие с ПАК и другими модулями
- Получение данных по запросу

## Общая архитектура и схема работы

Библиотека построена на базе шаблона singleton и реализует взаимодействие через статические методы класса [ORModule](ORModule.h).
Для получения данных от библиотеки программному модулю необходимо зарегистрировать и реализовать обработчик функций обратного вызова на базе класса [ormodulecallback](ormodulecallback.h).
Т.к. библиотека рассчитана на взаимодействие с различными источниками данных и брокерами сообщений в зависимости от конфигурации системы, для каждого источника данных/брокера сообщений предусмотрен отдельный адаптер.
В связи с этим, передача данных в библиотеку и получение данных из библиотеки осуществляется с помощью наследников базового класса [DataBlock](DataBlock.h). 

## Разработка программного модуля с использованием библиотеки ORModule

Как правило, программный модуль использует следующую последовательность действий.
1. Инициализация библиотеки с помощью `ORModule::init()`.
2. Обработка вызова `orOnReady()` в которой устанавливается статус модуля и запрашивается конфигурационный файл через вызов метода `ORModule::getConfig(...)`.
3. Обработка вызова `orGotConfig(...)`, разбор настроек, подключение к сторонним модулям через `ORModule::subscribeToService(...)` и выполнение требуемого функционала. Метод `orGotConfig(...)` может вызываться несколько раз из-за внесения изменений в настройки пользователем или другими модулями. Необходимо предусмотреть в программном модуле поддержку повторных вызовов.
4. При необходимости программный модуль отправляет в ПАК данные через вызов методов `ORModule::storeSourceData(...)`, `ORModule::storeEvent(...)` или `ORModule::sendNotification(...)`.
5. В случае подписки на данные сторонних модулей при появлении данных вызывается метод `orGotEvent(...)`.
6. Если в модуле заявлены действия, то при активации действия будет вызван метод `orGotAction(...)`.
7. В момент инициализации библиотеки запускается таймер, периодически вызывающий метод `orOnUpdate(...)`. Как правило, метод используется для проверки работоспособности подключений сторонних модулей, отправки статистики в систему или выполнении других периодических операций.

## Передача данных в библиотеку ORModule

Для взаимодействия с библиотекой ORModule данные упаковываются в наследники класса [DataBlock](DataBlock.h). Класс содержит базовые методы для чтения/записи данных. 
Обязательным условием использования класса DataBlock является переопределение метода `getBlockDescription()`.
Также, если структура данных используется для чтения из системы, требуется переопределить метод `createInstance()`.

Пример реализации структуры данных на базе класса DataBlock:
```c++
class DataStats : public DataBlock {
public:
    DataStats() = default;

    DataStats(long total, long losses) {
        setValue("total", total);
        setValue("losses", losses); }

protected:
    std::map<std::string, OR_DATA_TYPES> getBlockDescription() const override {
        return m_items;
    }

    std::map<std::string, OR_DATA_TYPES> m_items = {
            {"total", OR_TYPE_LONG},
            {"losses", OR_TYPE_LONG}};
};
```
В примере структура данных допускает поля "total" типа long и "losses" типа long. 
При попытке обращения к другим полям или использования полей с другими типами будет выброшено исключение.

Для записи значений используются методы `setValue(key, value)` или `setValueByType(key, value)`.
Первый метод требует точного соответствия типа, второй метод использует встроенные средства приведения типа к нужному.
Примеры правильного и неправильного использования:
```c++
block.setValue("total", 10); // правильно
block.setValue("total", 10.1); // неправильно, будет исключение
block.setValueByType("total", "10"); // правильно
block.setValueByType("total", 10.1); // правильно, будет выдано предупреждение
```

Для получения данных используется набор методов в соответствии с типом данных:
```c++
std::string getString(...);
bool getBool(...);
int getInt(...);
long getLong(...);
float getFloat(...);
double getDouble(...);
std::vector<double> getArray(...);
```
Для каждого метода можно указать значение по умолчанию, которое будет использовано если в структуре для требуемого поля не задано значение.
Для проверки наличия значения есть метод `bool hasValue(const std::string &key)`.

В библиотеке реализован базовый набор структур данных, размещенный в [datatypes](datatypes).

## Управление статусами модуля

**TODO: Беседный**

## Общая конфигурация библиотеки

Общая конфигурация библиотеки располагается по умолчанию в файле ``/etc/optirepair/config.json`` если не задано другое местоположение при вызове метода `ORModule::init(...)`.
Конфигурация представлена в виде json файла и содержит следующие секции в разделе ``connections``:
* ``brocker`` - используемый брокер;
* ``configdb`` - используемая БД конфигураций;
* ``sourcedb`` - используемая БД оперативных данных;
* ``eventdb`` - используемая БД событий.

Тип брокера/БД определяется по полю ``type``, параметры хранятся в поле ``config``. 
Примеры брокеров/БД:
* брокер MQTT:
```json
"brocker": {
      "type": "mqtt",
      "config": {
        "host"     : "127.0.0.1",
        "port"     : 1883,
        "login"    : "optirepair",
        "password" : "optirepair-ext"
      }
    }
```
* БД файловая
```json
"configdb": {
      "type": "file",
      "config": {
        "path": "/etc/optirepair/configs"
      }
    }
```
* БД system API
```json
"configdb": {
      "type": "systemapi",
      "config": {
        "host": "http://demo.pdm.petrsu.ru:8000"
      }
    }
```
* БД SQLite
```json
    "sourcedb": {
      "type": "sqlite",
      "config": {
        "path": "/opt/optirepair/data/source.sqlite"
      }
    }
```
* БД MySql
```json
    "sourcedb": {
      "type": "mysql",
      "config": {
        "host": "localhost",
	"port": 3306,
	"user": "optirepair",
	"password": "optirepair-ext"
      }
    }
```
* БД ClickHouse
```json
{
  "sourcedb": {
    "type": "clickhouse",
    "config": {
      "host": "localhost",
      "port": 8123,
      "database": "optirepair",
      "login": "",
      "password": ""
    }
  }
}
```
* БД MongoDB
```json
{
  "eventdb": {
    "type": "mongodb",
    "config": {
      "host"     : "localhost",
      "port"     : 27017,
      "database" : "optirepair",
      "login"    : "",
      "password" : ""
    }
  }
}
```


## Реализация адаптера хранилища данных

Для реализации адаптера хранилища данных требуется реализовать наследника класса [IDatabase.h](database/IDatabase.h), прописать создание экземпляра адаптера в [ORModuleImpl](ORModuleImpl.cpp) и добавить требуемые зависимости в CMakeLists.txt.
Адаптер хранилища данных содержит методы для работы с конфигурациями (БД конфигураций), оперативными данными (БД оперативных данных) и событиями (БД событий).
Допускается реализация содержимого методов отдельных БД при наличии диагностических сообщений об отсутствии остальных реализаций.
Обязательной является реализация метода `init(...)` для инициализации адаптера.

При необходимости (возникновение ошибки, асинхронная работа и т.п.) адаптер сообщает библиотеке требуемую информацию через функции обратного вызова, описанные в классе [IDatabaseCallback](database/IDatabaseCallback.h).

## Реализация адаптера брокера сообщений

Для реализации адаптера брокера сообщений требуется реализовать наследника класса [IBroker.h](brocker/IBrocker.h), прописать создание экземпляра адаптера в [ORModuleImpl](ORModuleImpl.cpp) и добавить требуемые зависимости в CMakeLists.txt.
Адаптер брокера сообщений содержит методы для работы с используемым брокером сообщений.

При необходимости (возникновение ошибки, асинхронная работа и т.п.) адаптер сообщает библиотеке требуемую информацию через функции обратного вызова, описанные в классе [IBrockerCallback](brocker/IBrockerCallback.h).
